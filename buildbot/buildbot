#!/usr/bin/perl -w

use strict;
use open IO => ":encoding(utf-8)";
use open ':std';
use Modern::Perl '2014';
use experimental 'smartmatch';

use FindBin qw($Bin);
use lib "$Bin/lib";

use Data::Dumper;
use Getopt::Long::Descriptive;
use Carp qw/confess/;
use File::Slurp;
use File::Path qw/rmtree/;
use JSON;
use LWP::UserAgent;
use File::Temp qw/tempfile/;
use HTTP::DAV;
use POSIX;
use Sys::Hostname;

sub api_get {
        my ($opt, $ua, $uri) = @_;

        my $curi=sprintf("%s/%s", $opt->api, $uri);
        my $r=eval { $ua->get($curi) };
        if (!defined($r) || !$r->is_success) {
                carp("Failed to reach api\n");
		return undef;
        }

        my $data=eval { from_json($r->decoded_content, { utf8  => 1 } ) };

        return $data;
}

sub api_post {
	my ($opt, $ua, $uri, $content) = @_;

	my $curi=sprintf("%s/%s", $opt->api, $uri);
	my $httpreq = HTTP::Request->new(POST => $curi);
	$httpreq->content_type('application/json;charset=UTF-8');
	$httpreq->content(to_json($content));
	my $response=eval { $ua->request($httpreq) };

	if (!defined($response) || !$response->is_success) {
		carp("Failed to reach api\n");
		return undef;
	}

	my $r=eval { from_json($response->decoded_content, { utf8  => 1 } ) };

	return $r;
}

sub job_claim {
	my ($ua, $opt, $job) = @_;
	my $uri=sprintf("/v1/job/%s/claim/%s", $job->{id}, $opt->sysname);
	my $result=api_get($opt, $ua, $uri);

	return (defined($result) && $result->{status} == 'ok');
}

sub job_return {
	my ($ua, $opt, $job, $return) = @_;
	my $uri=sprintf("/v1/job/%s/result/%s", $job->{id}, $return->{status});
	api_post($opt, $ua, $uri, $return);
}

sub job_get {
	my ($ua, $opt) = @_;

	# '{ "type": "build", "capabilities": [ "docker:bbb/buster", "mips" ] }'
	my $result=api_post($opt, $ua, "/v1/job/filter", {
		capabilities => $opt->capability,
		type => "build"
	});

	if (defined($result) && defined($result->{jobs})) {
		return $result->{jobs}[0];
	}

	return undef;
}

sub artifact_dircreate {
	my ($opt, $job) = @_;

	my $dir=sprintf("%s/%s", $opt->artifactdir, $job->{id});

	rmtree($dir);
	mkdir($dir);

	return $dir;
}

sub job_dispatch {
	my ($ua, $opt, $job) = @_;

	my $result={};

	my $adir=artifact_dircreate($opt, $job);
	my $configfile=sprintf("%s/config.json", $adir);

	open(my $fh, ">" . $configfile);
	print $fh to_json($job->{variables});
	close($fh);

	my $logfilename=sprintf("%s/logfile", $adir);
	open(my $logfh, ">" . $logfilename);

	# FIXME Need a timeout
	# FIXME store return code
	
	$result->{start}=strftime("%Y-%m-%dT%H:%M:%S", localtime(time()));

	my $pid = open(my $kid, "-|");
	defined($pid) || confess "can't fork: $!";
	if ($pid) {
		while (<$kid>) {
			print $_;
			print $logfh $_;
		}
		close($kid);

		my ($rc, $sig, $core) = ($? >> 8, $? & 127, $? & 128);	

		$result->{stop}=strftime("%Y-%m-%dT%H:%M:%S", localtime(time()));
		$result->{status}=($rc == 0) ? "ok" : "failed";
	} else {
		open(STDERR, ">&STDOUT");
		exec($opt->buildscript, $job->{id}, $adir, $configfile) || die "can't exec program: $!";
	}

	close($logfh);
	system("gzip $logfilename");

	my $pushfiles=artifact_push($opt, $job, $adir);
	$result->{artifacts}=$pushfiles;

	rmtree($adir);

	return $result;
}

sub artifact_push {
	my ($opt, $job, $adir) = @_;

	my $url="https://nuc.dynamic.uucico.de/artifacts";
	my $dav = HTTP::DAV->new();
	
	$dav->open( -url => $url )
		|| confess("Couldn't open $url: " . $dav->message . "\n");

	my $dir=sprintf("%s/%s", $url, $job->{id});

	$dav->mkcol( -url => $dir ) || printf("Oops - directory already exists\n");

	if ($dav->put(-local => $adir . "/*", -url => $dir)) {
		print("successfully uploaded multiple files to $dir\n");

		my $cwd=getcwd();
		chdir($adir),
		my @files=glob("*");
		chdir($cwd);

		return \@files;
	}

	print("put failed: " . $dav->message . "\n");
	return undef;
}

my ($opt, $usage) = describe_options(
	$FindBin::Script . ' %o <some-arg>',
	[ 'verbose|v',		"Verbose", { default => 0 } ],
	[ 'debug|d',		"Debug" ],
	[ 'api=s',		"API Endpoint", { required => 1 } ],
	[ 'sysname=s',		"System name for api", { default => hostname } ],
	[ 'capability|c=s@',	"Capability to claim jobs" ],
	[ 'buildscript|b=s',	"Build script to call with job definition", { required => 1 } ],
	[ 'artifactdir|a=s',	"Directory to create per job artifact directories", { default => "/tmp" } ],
	[],
	[ 'help',		"print usage message and exit", { shortcircuit => 1 } ],
);

my $ua=LWP::UserAgent->new();

if ($opt->debug) {
	$ua->add_handler("request_send",  sub { shift->dump; return });
	$ua->add_handler("response_done", sub { shift->dump; return });
}

while(42) {
	my $js=job_get($ua, $opt);
	if (defined($js)) {
		if (job_claim($ua, $opt, $js)) {
			my $return=job_dispatch($ua, $opt, $js);
			print Dumper($return);

			job_return($ua, $opt, $js, $return);
		}
	}
	sleep(10);
}
