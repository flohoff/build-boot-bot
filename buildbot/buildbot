#!/usr/bin/perl -w

use strict;
use open IO => ":encoding(utf-8)";
use open ':std';
use Modern::Perl '2014';
use experimental 'smartmatch';

use FindBin qw($Bin);
use lib "$Bin/lib";

use Data::Dumper;
use Getopt::Long::Descriptive;
use Cwd;
use Carp qw/confess/;
use File::Slurp;
use File::Path qw/rmtree/;
use JSON;
use LWP::UserAgent;
use File::Temp qw/tempfile/;
use HTTP::DAV;

sub api_post {
	my ($opt, $ua, $uri, $content) = @_;

	my $curi=sprintf("%s/%s", $opt->api, $uri);
	my $httpreq = HTTP::Request->new(POST => $curi);
	$httpreq->content_type('application/json;charset=UTF-8');
	$httpreq->content(to_json($content));
	my $response=$ua->request($httpreq);

	if (!$response->is_success) {
		print Dumper($response);
		confess("Failed to reach api\n");
	}

	my $r=eval { from_json($response->decoded_content, { utf8  => 1 } ) };

	if (!defined($r->{status}) || $r->{status} ne 'ok') {
		confess(sprintf("Request failed - API returned cause: %s", $r->{error}));
	}

	return $r;
}


sub job_get {
	my ($ua, $opt) = @_;

	# '{ "type": "build", "capabilities": [ "docker:bbb/buster", "mips" ] }'
	my $result=api_post($opt, $ua, "/v1/job/filter", {
		capabilities => $opt->capability,
		type => "build"
	});

	return $result->{jobs}[0];
}

sub artifact_dircreate {
	my ($opt, $job) = @_;

	my $dir=sprintf("%s/%s", $opt->artifactdir, $job->{id});

	rmtree($dir);
	mkdir($dir);

	return $dir;
}

sub job_dispatch {
	my ($ua, $opt, $job) = @_;

	my $result={};

	my $adir=artifact_dircreate($opt, $job);
	my $configfile=sprintf("%s/config", $adir);

	open(my $fh, ">" . $configfile);
	print $fh to_json($job->{variables});
	close($fh);
	
	open(my $logfh, sprintf(">%s/logfile", $adir));

	# FIXME Need a timeout
	# FIXME store return code
	
	$result->{start}=time();

	my $pid = open(my $kid, "-|");
	defined($pid) || confess "can't fork: $!";
	if ($pid) {
		while (<$kid>) {
			print $_;
			print $logfh $_;
		}
		close($kid);

		my ($rc, $sig, $core) = ($? >> 8, $? & 127, $? & 128);	

		$result->{stop}=time();
		$result->{status}=$rc;

		printf("Runtime %s seconds - returned %d\n", $result->{stop}-$result->{start}, $rc);
		printf($logfh "Runtime %s seconds - returned %d\n", $result->{stop}-$result->{start}, $rc);
	} else {
		open(STDERR, ">&STDOUT");
		exec($opt->buildscript, $job->{id}, $adir, $configfile) || die "can't exec program: $!";
	}

	close($logfh);

	my $pushrc=artifact_push($opt, $job, $adir);
	$result->{pushstatus}=$pushrc;

	rmtree($adir);

	return $result;
}

sub artifact_push {
	my ($opt, $job, $adir) = @_;

	my $url="https://nuc.dynamic.uucico.de/artifacts";
	my $dav = HTTP::DAV->new();
	
	$dav->open( -url => $url )
		|| confess("Couldn't open $url: " . $dav->message . "\n");

	my $dir=sprintf("%s/%s", $url, $job->{id});

	$dav->mkcol( -url => $dir ) || printf("Oops - directory already exists\n");

	if ($dav->put(-local => $adir . "/*", -url => $dir)) {
		print("successfully uploaded multiple files to $dir\n");
		return 0;
	}

	print("put failed: " . $dav->message . "\n");
	return 1;
}

my ($opt, $usage) = describe_options(
	$FindBin::Script . ' %o <some-arg>',
	[ 'verbose|v',		"Verbose", { default => 0 } ],
	[ 'api=s',		"API Endpoint", { required => 1 } ],
	[ 'capability|c=s@',	"Capability to claim jobs" ],
	[ 'buildscript|b=s',	"Build script to call with job definition", { required => 1 } ],
	[ 'artifactdir|a=s',	"Directory to create per job artifact directories", { default => "/tmp/" } ],
	[],
	[ 'help',		"print usage message and exit", { shortcircuit => 1 } ],
);

my $ua=LWP::UserAgent->new();

#$ua->add_handler("request_send",  sub { shift->dump; return });
#$ua->add_handler("response_done", sub { shift->dump; return });

while(42) {
	my $js=job_get($ua, $opt);
	if (defined($js)) {

		print Dumper($js);

		my $result=job_dispatch($ua, $opt, $js);

		print Dumper($result);

	}
	sleep(10);
}
